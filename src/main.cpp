#include <iostream>
#include <opencv2/opencv.hpp>
#include <stdint.h>
#include "../include/encrypt_kernel.hpp"
#include "../include/prbg_main_plcm.hpp"

int main () {

    double globalKey = 0.123456 ; //used for PRBGmain initialization. is a double value (0,0.5)
    double p = 0.3; //control parameter for the PRBGmain . is a value in (0,0.5)
    int numKeys =128 ;  // each iteration of the PRBG main is a resultant input seed...
                        //...for the future subsequent PRBGas as described by article
    int PRBGAiterations = 768 ;
    
    double sc ;

    //generating the keys and control parameters that will be fed to future PRBGas
    std::vector<double> keysAndControlPs = generatePRBGMainKeys( globalKey, p, 2*numKeys +1 , &sc ); // +1 for sc generation
    std::vector<double> prbga_results ;
    
    //now that the parameter needed to initialize the various PRBGAs are ready, we can launch the wrapper to the kernel dealing with beginning PRGAs execution
    PRBGAKernelWrapper(keysAndControlPs, prbga_results, sc, PRBGAiterations);

    // To access result for block 0 (contains the values generated by the PRBGA assigned to block 0), for example:


//DEBUG PRBGA value purpose :
int i;
    std::cout << "Block 0 - Output 1:\n";
    for ( i = 0; i < PRBGAiterations; ++i) {
        std::cout << prbga_results[i] << " ";
    }
    int blockID = 1;
    std::cout << "Block 1 - Output 1:\n";
    for ( i = 0; i < PRBGAiterations; ++i) {
        std::cout << prbga_results[i+blockID*PRBGAiterations] << " ";
    }
    

    std::cout << "Block 0 - Output 2:\n";
    for (int i = 0; i < PRBGAiterations; ++i) {
        std::cout << prbga_results[PRBGAiterations * numKeys + i] << " ";
    }
    std::cout << "Block 1 - Output 2:\n";
    for (int i = 0; i < PRBGAiterations; ++i) {
        std::cout << prbga_results[PRBGAiterations * numKeys + i + PRBGAiterations*1] << " ";
    }

    


    std::cout << "\n";




    //load the Frame (grayScale mode for now)
    //cv::Mat inputFrame = cv::imread("../testFrames/shrekAndDonkey.png", cv::IMREAD_GRAYSCALE);
    
    //quick check if frame exists
    //if( inputFrame.empty()) {
    //    std::cerr << "Failed to load Frame!\n";
    //    return -1;
    //}
   
    //cv::Mat encryptedFrame(inputFrame.size(), inputFrame.type() );

    //float seed = 0.7f; // for PRBG
    //float k = 0.5f; // control parameter for PiecewiseLinearChaoticMap (PLCM)


    //calling the wrapper for the kernel
    //encryptFrame(inputFrame, encryptedFrame, seed, k);

    //Copying the result back to the host environment
    //cv::imwrite("../testFrames/encrypted_output.png", encryptedFrame);

    //std::cout << "Encryption complete. Saved as encrypted_output.png\n";
    
    return 0;

}